# task8
сортировка выбором:

1. начинаем цикл по j, где j принимает значения от 0 до n
2. предположим, что j элемент - это min
3. начнем цикл с j+1 до n, в цикле последовательно сравниваем элементы с min 
{

если найдется arr[i] < min, то min = arr[i], индекс минимального теперь равен i // comps++;
}
4. после окончаниня цикла получаем индекс элемента с наименьшим значением 
5. если элемент с индексом j != min, swap(эллемент[j], элемент с наименьшим ззначением) //swaps++;
таким образом, постепенно вычисляя минимальный элемент в массиве, переставляя его на место j, получим отсортированный массив

5 4 3 2 1 -> 1 4 3 2 5 (поменяли местами 5 (arr[j]) и 1 (arr[индекс минимального])) -> 1 2 3 4 5 (поменяли местами 4 (arr[j]) и 2 (arr[индекс минимального]))



quicksort

1 2 4 3 5 
1. вычисляем pivot: arr[start + (finish-start)/2] (4)
2. i присваиваем значение start (0), j - значение finish (4)
3. начинаем цикл do while (i <= j)
3. начинаем цикл while по i (инкрементируем i, пока не найдется элемент, больший или равный pivot) (4)  // conps++;
4. начинаем цикл while по j (декрементируем j, пока не найдется элемент, меньший или равный pivot) (3)  // conps++;
5. проверяем, условие (i <= j), если выполняется (да), меняем элементы местами; i++, j--;, теперь массив выглядит так: 1 2 3 4 5, i  =  3, j = 2 //swaps++;
6. i <= j условие не выполняется, выходим из цикла
7. если i < finish (3 < 4), рекурсивно вызываем quicksort для массива (3 5)
    - start = 3, finish = finish, pivot = start
    - do while (3 <= 4) (i <= j)
    - while по i (остановится в 3) // comps++;
    - while по  j  (остановится в 3) // comps++;
    - на следующем шаге i++ и  j --, i > j, выходим из цикла 
    - рекурсивно ничего не вызываем, так как i < start и j = finish
8. если j > start (2 > 0), рекурсивно вызываем quicksort для массива (1 2 4)
    - start = 0, finish = 2, pivot = 2
    - do while (0 <= 4) (i <= j)
    - while по i (остановится в 2)
    - while по j  (остановится в 2) 
    - на следующем шаге i++, j-- выходим из цикла 
    - рекурсивно ничего не вызываем, так как i = start и j = finish


